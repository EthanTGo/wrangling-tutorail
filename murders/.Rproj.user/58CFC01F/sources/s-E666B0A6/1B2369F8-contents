#let's generate a random sample
#let's first make the data
beads <- rep(c("red","blue"), times = c(2,3))
#the sample() function does this
sample(beads, 1) #where 1 is one random out come
sample(beads, 5) #note how it does it without replacement


#so we need to use the replicate() function to repeeat the same experiment
B <- 10000
events <- replicate(B, sample(beads, 1))

#Note that an easier way is to make saample go with replacement like this
events <- sample(beads, B, replace = TRUE)
prop.table(table(events))


#the paste function is useful in combining strings like:
number <- "Three"
suit <- "Hearts"
paste(number, suit)
paste(letters[1:5], as.character(1:5))
#Note how there's a space

#to create a table with all possible combination we can use the expand.grid() function
expand.grid(pants = c("blue","black"), shirt = c("white", "grey", "plaid"))
#shows all the possible combination

#mking a deck of cards
suits <- c("Diamonds","Clubs", "Hearts", "Spades")
numbers <- c("Ace", "Deuce", "Three","Four","Five","Six","Seven","Eight","Nine","Ten","Jack","Queen","King")
deck <- expand.grid(number = numbers, suit = suits)
deck <- paste(deck$number , deck$suit)

#OK< how doe we use this, let's sy the probbility of getting a king in the  first draw
kings <- paste("King", suits)
mean(deck %in% kings)

#EZ, now let's use conditional probability
#combinations and permutations function


#permutations() computes, for any list of size "n", all thje different ways we can select r items, order matters 
install.packages("gtools")
library(gtools)
permutations(5,2)
# permutations of choosing 2 numbers from a list of 5, note that this is also without replacement, order matters
# 3, 1 is not the same as 1,3

all_phone_numbers <- permutations(10,7, v = 0:9) #v = 0:9 defines a vector from 0 to 9 instead of 1 to 10
n <- nrow(all_phone_numbers) #shows all the possible combinations, all the rows, there are a lot you can see from max.print
index <- sample(n,5) #take 5 numbers from the list of all the rows, tere are like 604800
all_phone_numbers[index,] #take that specific 5 sample


#computing all possible ways to choose 2 cards from 52, when order matters is
hands <- permutations(52,2,v= deck) #note how decks is of size 52
#when you print it there are going to be 2652 rows

first_card <- hands[,1]
second_card <- hands[,2] 
#grabs first and second column

#cases where the first card is a king
sum(first_card %in% kings) #tells how many of the first card has kings
#to calculate two kings  we use the conditional prob
sum(first_card %in% kings & second_card %in% kings) / sum(first_card %in% kings)
#all cases where kingsi s in first and second / cases where king is in the first

#what if the order does not matter, combinations() !!!!!!!
combinations(3,2)
#1 , 2 and 2,1 is the same things

#probability of getting 21
aces <- paste("Ace", suits)
facecard <- c("King", "Queen", "Jack", "Ten")
facecard <- expand.grid(number = facecard, suit = suits)
facecard <- paste(facecard$number, facecard$suit)

hands <- combinations(52,2, v = deck)
#now we count
mean(hands[,1] %in% aces & hands[,2] %in% facecard)
#here we use aces first (first row) because of how we ordered it, but to be sager
mean((hands[,1] %in% aces & hands[,2] %in% facecard) | (hands[,2] %in% aces & hands[,1] %in% facecard))
#this makes sure that we check both column, in case aces appears in the second column of result


#finding the natural 21 in blackjack using monte carlo simulation, doing it a lot of times
B <- 10000
results <- replicate(B, {
  hand <- sample(deck,2)
  (hand[1] %in% aces & hand[2] %in% facecard) | (hand[2] %in% aces & hand[1] %in% facecard)
})
mean(results)

#2 people have the same birthday
# 1 to 365
n <- 50
bdays <- sample(1:365, n, replace =TRUE)

#the function duplicated returns the instance a number appears twice
duplicated(c(1,2,3,1,4,3,5))
#returns a bool vector, where the second time 1 and 3 appears, is represented as TRUE because they are duplicated

any(duplicated(bdays))

#let's dod this MONTE Carlo simulation
B <- 10000
results <- replicate(B, {
  bdays <- sample(1:365, n , replace = TRUE)
  any(duplicated(bdays))
})
mean(results)

#make a function to create probability for the bityhday problem, using a MONTE CARLO
compute_prob <- function(n, B= 10000){
  same_day <- replicate(B, {
    bdays  <- sample(1:365,n,replace = TRUE)
    any(duplicated(bdays))
  })
  mean(same_day)
}

n <- seq(1:60)
#we can use for loops to go from 1 - 60 but there's annother way of doing this, sapply is the way to go
x <- 1:10
sqrt(x)
#note how the function sqrt applies to element x, this does not applyto our function
#instead we can use sapply
sapply(x, sqrt) #see how it does the same things, this applies sqrt to every element in x

#to find the exact probability, let's find the probability every birthday is distinct
exact_prob <- function(n){
  prob_unique <- seq(365, 365 - n + 1)/365
  1 - prod(prob_unique) #product multiplies the sequencne 
}

eprob <- sapply(n,exact_prob)
plot(n,prob)
lines(n,eprob, col = "red")

#code for Monte Carlo Simulation
#stick strategy
B <- 10000
stick <- replicate(B, {
  doors <- as.character(1:3)
  prize <- sample(c("car","goat","goat"))
  prize_door <- doors[prize == "car"]
  my_pick  <- sample(doors, 1)
  show <- sample(doors[!doors %in% c(my_pick, prize_door)],1)
  stick <- my_pick
  stick == prize_door
})
mean(stick)

#switch strategy code
switch <- replicate(B, {
  doors <- as.character(1:3)
  prize <- sample(c("car","goat","goat"))
  prize_door <- doors[prize == "car"]
  my_pick  <- sample(doors, 1)
  show <- sample(doors[!doors %in% c(my_pick, prize_door)], 1)
  stick <- my_pick
  switch <- doors[!doors%in%c(my_pick, show)]
  switch == prize_door
})
mean(switch)

#EXERCISE 1................................................................

# Assign a variable 'n' as the number of remaining games.
n = 6

# Assign a variable `outcomes` as a vector of possible game outcomes, where 0 indicates a loss and 1 indicates a win for the Cavs.
outcomes <- c(0,1)

# Assign a variable `l` to a list of all possible outcomes in all remaining games. Use the `rep` function on `list(outcomes)` to create list of length `n`.
l <- rep(list(outcomes),n)

# Create a data frame named 'possibilities' that contains all combinations of possible outcomes for the remaining games.
possibilities <- expand.grid(l)
# [0,1,1,1,1,1]

# Create a vector named 'results' that indicates whether each row in the data frame 'possibilities' contains enough wins for the Cavs to win the series.
results <- rowSums(possibilities) >= 4 #sums all the numbers in a row 

# Calculate the proportion of 'results' in which the Cavs win the series. Print the outcome to the console.

#EXERCISE 3...........................................................
# Let's assign the variable 'p' as the vector of probabilities that team A will win.
p <- seq(0.5, 0.95, 0.025)

# Given a value 'p', the probability of winning the series for the underdog team B can be computed with the following function based on a Monte Carlo simulation:
prob_win <- function(p){
  B <- 10000
  result <- replicate(B, {
    b_win <- sample(c(1,0), 7, replace = TRUE, prob = c(1-p, p))
    sum(b_win)>=4
  })
  mean(result)
}

# Apply the 'prob_win' function across the vector of probabilities that team A will win to determine the probability that team B will win. Call this object 'Pr'.
Pr <- sapply(p,prob_win)
plot(p, Pr)

#Exercise 4 ........................................
# Given a value 'p', the probability of winning the series for the underdog team B can be computed with the following function based on a Monte Carlo simulation:
prob_win <- function(N, p=0.75){
  B <- 10000
  result <- replicate(B, {
    b_win <- sample(c(1,0), N, replace = TRUE, prob = c(1-p, p))
    sum(b_win)>=(N+1)/2
  })
  mean(result)
}

# Assign the variable 'N' as the vector of series lengths. Use only odd numbers ranging from 1 to 25 games.
N <- seq(1,25,2)

# Apply the 'prob_win' function across the vector of series lengths to determine the probability that team B will win. Call this object `Pr`.
Pr <- sapply(N, prob_win)

# Plot the number of games in the series 'N' on the x-axis and 'Pr' on the y-axis.
plot(N, Pr)


#some useful function such as: pnorm, dnorm, rnorm
#pnorm is the probability cdf of a normal
#dnorm is the dennsity function of a normal
#rnorm generates values that represents a normal distributions
#qnorm gives us the quantiles - usefull for inverse


#for t distribution, dt, qt, rt, pt



n <- 1000
loss_per_forecloseure <- -200000
p <- 0.02
defaults <- sample(c(0,1), n, prob = c(1-p,p), replace = TRUE)
sum(defaults * loss_per_forecloseure)

B <- 10000
losses <- replicate(B, {
  defaults <- sample(c(0,1), n, prob = c(1-p,p), replace = TRUE)
  sum(defaults * loss_per_forecloseure)
})


library(tidyverse) # this package is used to load the ggplot2 package and dplyr
#grammar of graphics 
library(dslabs)
a <- data.frame(losses_in_millions = losses/10^6)
data.frame(losses_in_millions = losses/10^6) %>% ggplot(aes(losses_in_millions)) + geom_histogram(bindwidth = .6, col = "black")


#using the CLT, we know that the mean and standard error of our current problem is in the form
n * (p * loss_per_forecloseure + (1-p)*0) #mean
sqrt(n) * abs(loss_per_forecloseure) * sqrt(p*(1-p)) #standard dev


- loss_per_forecloseure  * p/(1-p)

